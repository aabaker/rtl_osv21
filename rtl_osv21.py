#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Script to record 433MHz dat in search of packets from Oregon Scientific weather sensors.
"""

import os
import re
import sys
import time
import numpy
import urllib
import struct
from datetime import datetime, timedelta

from _decode import readRTLFile


# Wunderground PWS Base URL
PWS_BASE_URL = "http://weatherstation.wunderground.com/weatherstation/updateweatherstation.php"

# Base path for the various files needed/generated by rlt_osv21.py
_BASE_PATH = os.path.dirname(os.path.abspath(__file__))

# Files
## Wunderground Configuration
CONFIG_FILE = os.path.join(_BASE_PATH, 'rtl_osv21.config')
## State file for keeping track of rainfall
STATE_FILE = os.path.join(_BASE_PATH, 'rtl_osv21.state')
## Temporary data file
RTL_DATA_FILE = os.path.join(_BASE_PATH, 'rtlsdr_433MHz.dat')


def loadConfig():
	"""
	Read in the configuration file and return a dictionary of the 
	parameters.
	"""
	
	# RegEx for parsing the configuration file lines
	configRE = re.compile(r'\s*:\s*')

	# Initial values
	config = {'verbose': False, 
		  'rtlsdr': None,
		  'duration': 90.0, 
		  'retainData': False,  
		  'useTimeout': False, 
		  'includeIndoor': False}

	# Parse the file
	try:
		fh = open(CONFIG_FILE, 'r')
		for line in fh:
			line = line.replace('\n', '')
			## Skip blank lines
			if len(line) < 3:
				continue
			## Skip comments
			if line[0] == '#':
				continue
				
			## Update the dictionary
			key, value = configRE.split(line, 1)
			config[key] = value
		fh.close()
		
		# Float type conversion
		config['duration'] = float(config['duration'])
		
		# Boolean type conversions
		config['verbose'] = bool(config['verbose'])
		config['useTimeout'] = bool(config['useTimeout'])
		config['retainData'] = bool(config['retainData'])
		config['includeIndoor'] = bool(config['includeIndoor'])
		
	except IOError:
		pass
		
	# Done
	return config


def loadState():
	"""
	Load in the state file needed to keep track of various values.
	"""
	
	# RegEx for parsing the configuration file lines
        configRE = re.compile(r'\s*:\s*')
	
	state = {}
	
	try:
		fh = open(STATE_FILE, 'r')
		for line in fh:
			line = line.replace('\n', '')
			## Skip blank lines
			if len(line) < 3:
				continue
			## Skip comments
			if line[0] == '#':
				continue
				
			## Update the dictionary
			key, value = configRE.split(line, 1)
			date, value = value.split(',', 1)
			state[key] = (float(date), float(value))
		fh.close()
		
	except IOError:
		pass
		
	return state


def saveState(state):
	"""
	Save the state file needed to keep track of various.
	"""
	
	tNowLocal = datetime.now()
	
	try:
		fh = open(STATE_FILE, 'w')
		fh.write("########################################\n")
		fh.write("#                                      #\n")
		fh.write("# rtl_osv21.py State File              #\n")
		fh.write("#                                      #\n")
		fh.write("# Updated: %s LT #\n" % tNowLocal)
		fh.write("#                                      #\n")
		fh.write("########################################\n")
		
		for key,(date,value) in state.iteritems():
			fh.write("%s: %f,%f\n" % (key, date, value))
			
		fh.close()
		
		return True
		
	except IOError:
		return False


def nibbles2value(nibbles):
	"""
	Convert a sequence of bits into list of integer nibbles.
	"""
	
	# A nibbles is 4 bits
	n = len(nibbles)/4
	
	# Loop over the nibbles
	out = []
	for i in xrange(n):
		out.append( (nibbles[4*i+3]<<3) | (nibbles[4*i+2]<<2) | (nibbles[4*i+1]<<1) | nibbles[4*i+0] )
		
	# Done
	return out


def checksum(bits):
	"""
	Compute the byte-based checksum for a sequence of bits.
	"""
	
	# Bits -> Integers
	values = nibbles2value(bits)
	
	# Sum
	value = sum(values)
	
	# Convert to an 8-bit value
	value = (value & 0xFF) + (value >> 8)
	
	# Done
	return value


def decodePacketv21(packet, wxData=None, verbose=False):
	"""
	Given a sequence of bits try to find a valid Oregon Scientific v2.1 
	packet.  This function returns a status code of whether or not the packet
	is valid, a dictionary of values (keyed off the WUnderground PWS 
	keywords) and the number of bytes used.
	
	Supported Sensors:
	  * 5D60 - BHTR968 - Indoor temperature/humidity/pressure
	  * 2D10 - RGR968  - Rain gauge
	  * 3D00 - WGR968  - Anemometer
	  * 1D20 - THGR268 - Outdoor temperature/humidity
	  * 1D30 - THGR968 - Outdoor temperature/humidity
	
	PWS Keyword List:
	  * http://wiki.wunderground.com/index.php/PWS_-_Upload_Protocol
	"""
	
	# If an input dictionary is not provided, create one
	if wxData is None:
		wxData = {}
 		
 	# Packet validity
 	validPacket = False
 	
 	# Check for a valid sync word.  If data has been passed to this function 
 	# then it already has a valid preamble.
	if nibbles2value(packet[16:20])[0] == 10:
		## Try to figure out which sensor is present so that we can get 
		## the packet length
		sensor = ''.join(["%x" % i for i in nibbles2value(packet[20:36])])
		if sensor == '5d60':
			ds = 96
		elif sensor == '2d10':
			ds = 84
		elif sensor == '3d00':
			ds = 88
		elif sensor == '1d20':
			ds = 80
		elif sensor == '1d30':
			ds = 80
		else:
			ds = len(packet)-16
			
		## Report
		if verbose:
			print 'preamble ', packet[ 0:16], ["%x" % i for i in nibbles2value(packet[0:16])]
			print 'sync     ', packet[16:20], ["%x" % i for i in nibbles2value(packet[16:20])]
			print 'sensor   ', packet[20:36], ["%x" % i for i in nibbles2value(packet[20:36])]
			print 'channel  ', packet[36:40], ["%x" % i for i in nibbles2value(packet[36:40])]
			print 'code     ', packet[40:48], ["%x" % i for i in nibbles2value(packet[40:48])]
			print 'flags    ', packet[48:52], ["%x" % i for i in nibbles2value(packet[48:52])]
			print 'data     ', packet[52:ds], ["%x" % i for i in nibbles2value(packet[52:ds])]
			print 'checksum ', packet[ds:ds+8], ["%x" % i for i in nibbles2value(packet[ds:ds+8])], "%x" % checksum(packet[20:ds])
			print 'postamble', packet[ds+8:ds+16]
			print '---------'
			
		## Compute the checksum and compare it to what is in the packet
		ccs = checksum(packet[20:ds])
		ccs1 = ccs & 0xF
		ccs2 = (ccs >> 4) & 0xF
		ocs1, ocs2 = nibbles2value(packet[ds:ds+8])
		if ocs1 == ccs1 and ocs2 == ccs2:
			### We have a valid packet!
			
			if sensor == '5d60':
				#### Indoor temperature in C
				temp = nibbles2value(packet[52:64])
				temp = 10*temp[2] + temp[1] + 0.1*temp[0]
				if sum(packet[64:68]) > 0:
					temp *= -1
				if verbose:
					print "-> ", temp*9.0/5.0 + 32, 'F'
					
				#### Indoor relative humidity as a percentage
				humi = nibbles2value(packet[68:76])
				humi = 10*humi[1]+humi[0]
				if verbose:
					print "-> ", humi, '%'
					
				#### Indoor "comfort level"
				comf = nibbles2value(packet[76:80])[0]
				if comf == 0:
					comf = 'normal'
				elif comf == 4:
					comf = 'comfortable'
				elif comf == 8:
					comf = 'dry'
				elif comf == 0xC:
					comf = 'wet'
				else:
					comf = "0x%X" % comf
				if verbose:
					print "-> ", comf
					
				#### Barometric pressure in mbar
				baro = nibbles2value(packet[80:88])
				baro = 10*baro[1] + baro[0] + 856
				if verbose:
					print "-> ", baro/33.8638866667, 'in-Hg'
					
				#### Pressure-based weather forecast
				fore = nibbles2value(packet[92:96])[0]
				if fore == 2:
					fore = 'cloudy'
				elif fore == 3:
					fore = 'rainy'
				elif fore == 6:
					fore = 'partly cloudy'
				elif fore == 0xC:
					fore = 'sunny'
				else:
					fore = "0x%X" % fore
				if verbose:
					print "-> ", fore
					
				validPacket = True
				wxData['indoortempf'] = round(temp*9.0/5.0 + 32, 2)
				wxData['indoorhumidity'] = round(humi, 0)
				wxData['baromin'] = round(baro/33.8638866667, 2)
				wxData['comfort'] = comf
				wxData['forecast'] = fore

			elif sensor == '2d10':
				##### Rainfall rate in mm/hr
				rrate = nibbles2value(packet[52:64])
				rrate = 10*rrate[2] + rrate[1] + 0.1*rrate[0]
				if verbose:
					print '=>', rrate/25.4, 'in/hr'
					
				##### Total rainfall
				rtotl = nibbles2value(packet[64:84])
				rtotl = 1000*rtotl[4] + 100*rtotl[3] + 10*rtotl[2] + rtotl[1] + rtotl[0]
				if verbose:
					print '=>', rtotl/25.4, 'inches'
					
				validPacket = True
				wxData['dailyrainin'] = round(rtotl/25.4, 2)

			elif sensor == '3d00':
				#### Wind direction in degrees (N = 0)
				wdir = nibbles2value(packet[52:64])
				wdir = 100*wdir[2] + 10*wdir[1] + wdir[0]
				if verbose:
					print '@>', wdir, 'deg'
					
				#### Gust wind speed in m/s
				gspd = nibbles2value(packet[64:76])
				gspd = 10*gspd[2] + gspd[1] + 0.1*gspd[0]
				if verbose:
					print '@>', gspd*2.23694, 'mph'
					
				#### Average wind speed in m/s
				aspd = nibbles2value(packet[76:88])
				aspd = 10*aspd[2] + aspd[1] + 0.1*aspd[0]
				if verbose:
					print '@>', aspd*2.23694, 'mph'
					
				validPacket = True
				wxData['windspeedmph'] = round(aspd*2.23694, 2)
				wxData['windgustmph'] = round(gspd*2.23694, 2)
				wxData['winddir'] = round(wdir, 0)
	
			elif sensor == '1d20':
				#### Temperature in C
				temp = nibbles2value(packet[52:64])
				temp = 10*temp[2] + temp[1] + 0.1*temp[0]
				if sum(packet[64:68]) > 0:
					temp *= -1
				if verbose:
					print "-> ", temp*9.0/5.0 + 32, 'F'
					
				#### Relative humidity as a percentage
				humi = nibbles2value(packet[68:76])
				humi = 10*humi[1]+humi[0]
				if verbose:
					print "-> ", humi, '%'
					
				validPacket = True
				wxData['temp2f'] = round(temp*9.0/5.0 + 32, 2)
	
			elif sensor == '1d30':
				#### Temperature in C
				temp = nibbles2value(packet[52:64])
				temp = 10*temp[2] + temp[1] + 0.1*temp[0]
				if sum(packet[64:68]) > 0:
					temp *= -1
				if verbose:
					print "-> ", temp*9.0/5.0 + 32, 'F'
					
				#### Relative humidity as a percentage
				humi = nibbles2value(packet[68:76])
				humi = 10*humi[1]+humi[0]
				if verbose:
					print "-> ", humi, '%'
					
				#### Battery status?
				batr = nibbles2value(packet[76:80])[0]
				if verbose:
					print "-> ", batr & 0x8
					
				##### Computed dew point from the Magnus formula
				##### See: http://en.wikipedia.org/wiki/Dew_point
				b = 17.67
				c = 243.5
				dewpt = numpy.log(humi/100.0) + b*temp/(c + temp)
				dewpt = c*dewpt / (b - dewpt)
					
				validPacket = True
				wxData['tempf'] = round(temp*9.0/5.0 + 32, 2)
				wxData['humidity'] = round(humi, 0)
				wxData['dewptf'] = round(dewpt*9.0/5.0 + 32, 2)
	else:
		ds = 0
	
	# Adjust the packet size for (1) the preamble length and (2) the fact 
	# that the v2.1 format doubles the bits.
	ds += 16
	ds *= 2
	
	# Return the packet validity, data dictionary, and the packet size
	return validPacket, wxData, ds


def record433MHzData(filename, duration, rtlsdrPath=None, useTimeout=False):
	"""
	Call the "rtl_sdr" program to record data at 433.8 MHz for the specified 
	duration in second to the specified filename.  
	
	Keywords accepted are:
	  * 'rtlsdrPath' to specify the full path of the executable and 
	  * 'useTimeout' for whether or not to wrap the "rtl_sdr" call with 
	    "timeout".  This feature is useful on some systems, such as the 
	    Raspberry Pi, where the "rtl_sdr" hangs after recording data.
	"""
	
	# Setup the arguments for the call
	frequency = 433.8e6
	sampleRate = 1e6
	samplesToRecord = int(duration*sampleRate)
	
	# Setup the program
	if rtlsdrPath is None:
		cmd = "rtl_sdr"
	else:
		cmd = rtlsdrPath
	cmd = "%s -f %i -s %i -n %i %s" % (cmd, frequency, sampleRate, samplesToRecord, filename)
	if useTimeout:
		timeoutPeriod = duration + 10
		cmd = "timeout -s 9 %i %s" % (timeoutPeriod, cmd)
		
	# Call
	os.system(cmd)
	
	# Done
	return True


def main(args):
	# Read in the configuration file
	config = loadConfig()
	
	# Record some data
	record433MHzData(RTL_DATA_FILE, config['duration'], rtlsdrPath=config['rtlsdr'], useTimeout=config['useTimeout'])
	
	# Find the bits in the freshly recorded data and remove the file
	fh = open(RTL_DATA_FILE, 'rb')
	bits = readRTLFile(fh)
	fh.close()

	if not config['retainData']:
		try:	
			os.unlink(RTL_DATA_FILE)
		except Exception, e:
			print "ERROR: cannot remove data file; %s" % str(e)
			
	# Read in the previous state and pre-load the data dictionary.  This helps keep the 
	# data stream sent to WUnderground "whole".
	state = loadState()
	tNowLocal = datetime.now()
	tNowLocal = float(tNowLocal.strftime("%s.%f"))
	
	wxData = {'dateutc': datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")}
	for key in state.keys():
		if key in ('dailyrainin',):
			continue
		wxData[key] = state[key][1]
		
	# Find the packets and save the output
	i = 0
	while i < len(bits)-32:
		## Check for a valid preamble (and its logical negation counterpart)
		if sum(bits[i:i+32:2]) == 16 and sum(bits[i+1:i+1+32:2]) == 0:
			try:
				packet = bits[i::2]
				valid, wxData, ps = decodePacketv21(packet, wxData, verbose=config['verbose'])
				
				### If the packet isn't valid, try the logical inverse that comes with v2.1
				if not valid:
					packet = [1-b for b in bits[i+1::2]]
					valid, wxData, ps = decodePacketv21(packet, wxData, verbose=config['verbose'])
				i += 1
				
			except IndexError:
				i += 1
					
		else:
			i += 1
			
	# Report
	try:
		inside = "%.1f F with %i%% humidity (%s)" % (wxData['indoortempf'], wxData['indoorhumidity'], wxData['comfort'])
		print "Inside Conditions:"
		print " "+inside
	except KeyError, e:
		pass
	try:
		outside = "%.1f F with %i%% humidity (dew point %.1f F)" % (wxData['tempf'], wxData['humidity'], wxData['dewptf'])
		print "Outside Conditions:"
		print " "+outside
	except KeyError, e:
		pass
	try:
		if 'dailyrainin' in state.keys():
			rain = "%.2f in since local midnight" % (wxData['dailyrainin']-state['dailyrainin'][1],)
		else:
			rain = "%.2f in since last reset" % wxData['dailyrainin']
		print "Rain:"
		print " "+rain
	except KeyError, e:
		pass
	try:
		wind = "Average %.1f mph with gusts of %.1f mph from %i degrees" % (wxData['windspeedmph'], wxData['windgustmph'], wxData['winddir'])
		print "Wind:"
		print " "+wind
	except KeyError, e:
		pass
	try:
		forecast = "%s (%.2f in-Hg)" % (wxData['forecast'], wxData['baromin'])
		print "Forecast:"
		print " "+forecast
	except KeyError, e:
		pass
		
	# Prepare the data for posting
	## Account information, software type, and action
	wxData['ID'] = config['ID']
	wxData['PASSWORD'] = config['PASSWORD']
	wxData['softwaretype'] = "rtl_osv21"
	wxData['action'] = "updateraw"
	
	## Strip out the comfort/forecast values
	try:
		del wxData['comfort']
        	del wxData['forecast']
	except KeyError:
		pass
		
	## Strip out the indoor values if requested
	if not config['includeIndoor']:
		try:
			del wxData['indoortempf']
			del wxData['indoorhumidity']
		except KeyError:
			pass
			
	## Update the daily rain total
	if 'dailyrainin' in wxData.keys():
		if 'dailyrainin' in state.keys():
			### We have a reference to use in order to get the daily amount
			prevRainfall = 1.0*state['dailyrainin'][1]
			
			wxData['dailyrainin'] -= prevRainfall
			wxData['dailyrainin'] = wxData['dailyrainin'] if wxData['dailyrainin'] >= 0.0 else 0.0
		
			### Update the state as needed
			if tNowLocal - state['dailyrainin'][0] > 86400:
				state['dailyrainin'] = (tNowLocal, wxData['dailyrainin']+prevRainfall)
				
		else:
			### Otherwise, make a new state file
			tMidnightLocal = datetime.now()
			tMidnightLocal = tMidnightLocal.replace(hour=0, minute=0, second=0, microsecond=0)
			tMidnightLocal = float(tMidnightLocal.strftime("%s.%f"))
			state['dailyrainin'] = (tMidnightLocal, wxData['dailyrainin'])
			
			### Cleanup so that nothing is sent to Wunderground about the rain
			del wxData['dailyrainin']
			
	# Update the current state using wxData and save it to a file
	for key in wxData:
		if key in ('ID', 'PASSWORD', 'dateutc', 'action', 'softwaretype', 'dailyrainin'):
			continue
		state[key] = (tNowLocal, wxData[key])
	saveState(state)
	
	# Post to Wunderground for the PWS protocol (if there is something 
	#interesting to send)
	if len(wxData.keys()) > 3:
		## Convert to a GET-safe string
		wxData = urllib.urlencode(wxData)
		url = "%s?%s" % (PWS_BASE_URL, wxData)
		if config['verbose']:
			print url
			
		## Send
		uh = urllib.urlopen(url)
		print "WUnderground PWS update status: %s" % uh.read()
		uh.close()


if __name__ == "__main__":
	main(sys.argv[1:])
